# ЛАБОРАТОРНЫЕ РАБОТЫ ПО ОС

Репозиторий с лабораторными работами по курсу **"Операционные системы"** (ОС).

Все работы выполнены на **C** с использованием системных вызовов Linux/Unix, Makefile для сборки и инструментов диагностики (strace).


## Структура репозитория

| Работа | Тема | Основные концепции |
|--------|------|-------------------|
| [**lab1_var5**](#lab1-процессы-и-управление-процессами) | Процессы и управление процессами | fork, exec, wait, системные вызовы |
| [**lab2_var5**](#lab2-многопоточность-и-оптимизация) | Многопоточность и оптимизация | pthread, синхронизация, бенчмарк |
| [**lab3_var5**](#lab3-синхронизация-и-взаимодействие-процессов) | Синхронизация и взаимодействие | mutex, semaphore, IPC, condition variables |
| [**lab4_var5**](#lab4-динамические-библиотеки) | Динамические библиотеки | dlopen, dlsym, .so файлы, linker |
| [**strace**](#strace-диагностика-системных-вызовов) | Диагностика системных вызовов | strace, анализ системных вызовов |
| [**cp_var23**](#cp_var23-курсовой-проект) | Курсовой проект | Архитектура, ZeroMQ, сетевое взаимодействие |


### Требования
- **GCC** (C99+)
- **POSIX-совместимая ОС** (Linux, macOS, WSL2)
- **Python 3** (для визуализации результатов в lab2)


## Описание лабораторных работ

### LAB1: Процессы и управление процессами

**Задача:** Практическое изучение создания и управления процессами в ОС.

**Ключевые концепции:**
- Создание новых процессов (fork)
- Замена образа процесса (exec)
- Ожидание завершения процессов (wait)
- Работа с PID, родительскими и дочерними процессами

**Файлы:**
- `parent.c` — родительский процесс
- `child.c` — дочерний процесс
- `out.txt` — результаты выполнения

**Пример использования:**
```bash
cd lab1_var5
gcc child.c -o child.out
gcc parent.c -o parent.out
./parent.out

# Результаты будут выведены на экран и сохранены в out.txt
```

**Системные вызовы:**
- `fork()` — создание процесса
- `exec()` — замена образа
- `wait()` / `waitpid()` — ожидание завершения
- `getpid()` / `getppid()` — получение PID

---

### LAB2: Многопоточность и оптимизация

**Задача:** Изучение многопоточности и сравнение производительности различных подходов.

**Функционал:**
- Реализация многопоточной программы
- Бенчмарк производительности с параметрами $10^7$ и $10^8$ элементов
- Тестирование с различным количеством потоков
- Построение графиков результатов

**Файлы:**
- `main.c` — основная программа с поддержкой многопоточности
- `graphs.py` — визуализация результатов
- `bench/10^7/` — результаты для 10 млн элементов
- `bench/10^8/results.csv` — данные бенчмарка

**Использование:**
```bash
cd lab2_var5
gcc -pthread -o program.out main.c -lm

# Запуск бенчмарка с 10 млн элементов и 10 итерациями на 12 потоках
./program.out -n 10000000 --bench -r 10 -t 12

# Запуск бенчмарка с 100 млн элементов и 5 итерациями
./program.out -n 100000000 --bench -r 5 -t 12

# Построение графиков результатов
python3 graphs.py
```

**Параметры программы:**
- `-n <число>` — количество элементов обработки
- `--bench` — включить режим бенчмарка
- `-r <число>` — количество итераций измерения
- `-t <число>` — количество рабочих потоков

**Анализируемые метрики:**
- Влияние количества потоков на время выполнения
- Масштабируемость алгоритма (speedup)
- Оверхед синхронизации между потоками
- Зависимость от размера входных данных

---

### LAB3: Синхронизация и взаимодействие процессов

**Задача:** Практическое применение механизмов синхронизации и межпроцессного взаимодействия.

**Ключевые концепции:**
- Синхронизация между процессами
- Мьютексы и семафоры
- Условные переменные
- Межпроцессное взаимодействие (IPC)
- Избегание race conditions и deadlocks
- Безопасная работа с критическими секциями

**Файлы:**
- `parent.c` — родительский процесс (координатор)
- `child.c` — дочерний процесс (рабочий)
- `out.txt` — лог выполнения

**Пример:**
```bash
cd lab3_var5
gcc child.c -o child.out
gcc parent.c -o parent.out
./parent.out

# Демонстрирует:
# - Безопасный обмен данными между процессами
# - Синхронизацию доступа к критическим секциям
# - Правильное использование семафоров и мьютексов
```

**Используемые примитивы синхронизации:**
- `pthread_mutex_t` — мьютекс для взаимного исключения
- `sem_t` — семафор (считающий семафор)
- `pthread_cond_t` — условная переменная для сигнализации
- Трубы (pipes) и именованные каналы (FIFO) для IPC

---

### LAB4: Динамические библиотеки

**Задача:** Создание и использование динамических библиотек с двумя реализациями функций.

**Функции (Вариант 5):**

| № | Название | Сигнатура | Реализация 1 | Реализация 2 |
|---|----------|-----------|--------------|--------------|
| 1 | Интеграл sin(x) | `float SinIntegral(float A, float B, float e)` | Метод прямоугольников | Метод трапеций |
| 6 | Число e | `float E(int x)` | Формула $(1 + \frac{1}{x})^x$ | Сумма ряда $\sum_{n=0}^{x} \frac{1}{n!}$ |

**Структура проекта:**
```
lab4_var5/
├── my_libs/
│   ├── lib.h           # Контракт функций (заголовок)
│   ├── librealize1.c   # Первая реализация
│   └── librealize2.c   # Вторая реализация
└── programs/
    ├── program1.c      # Статическое связывание (compile-time)
    └── program2.c      # Динамическое связывание (runtime, dlopen)
```

**Запуск:**

Создание объектных файлов библиотек:
```bash
cd lab4_var5/my_libs
gcc -c -fPIC -Wall librealize1.c -o lib1.o
gcc -c -fPIC -Wall librealize2.c -o lib2.o
```

Создание shared objects:
```bash
gcc -shared -o lib1.so lib1.o
gcc -shared -o lib2.so lib2.o
```

Компиляция первой программы (линковка с библиотекой `lib1`):
```bash
# запускаем из корня lab4_var5
gcc programs/program1.c -L./my_libs -l1 -lm -Wl,-rpath='${ORIGIN}/../my_libs' -o program1.out
./program1.out
```

Компиляция второй программы (использует dlopen/dlsym):
```bash
gcc programs/program2.c -ldl -lm -o program2.out
./program2.out
```

**Ключевые функции dlopen/dlsym:**
```c
// Загрузка библиотеки
void *current_lib = dlopen("../my_libs/lib1.so", RTLD_LAZY);

// Получение адреса функции
float (*func)(float, float, float) = dlsym(current_lib, "SinIntegral");

// Вызов функции
float result = func(0.0, M_PI, 0.001);

// Выгрузка
dlclose(current_lib);
```


### STRACE: диагностика системных вызовов

Для всех лабораторных работ использовался только `strace` — запуск итогового бинарника и запись трассировки в файл. Другие инструменты для анализа с `strace` не применялись.

Примеры запуска (запись в файл через `2>`; при необходимости добавлять `-f` для дочерних процессов):

```bash
# lab1
cd lab1_var5
strace ./parent.out

# lab2
cd lab2_var5
strace ./program.out

# lab3
cd lab3_var5
strace ./parent.out

# lab4
cd lab4_var5
strace ./program1.out

# пример с дочерними процессами
strace -f ./parent.out

# для записи в файл я использовал 2> (перенаправления stderr)
strace ./program.out 2> strace.log
```

### CP_VAR23: Курсовой проект

**Тема:** Клиент-серверная система передачи мгновенных сообщений с групповыми чатами

**Описание:**
Полнофункциональная система обмена сообщениями между несколькими клиентами в реальном времени через центральный сервер. Поддерживает как прямую переписку, так и групповые чаты.

**Функциональность:**

| Функция | Описание |
|---------|----------|
| **Регистрация** | Клиент подключается к серверу с уникальным логином |
| **Личные сообщения** | Отправка сообщений другому клиенту по логину |
| **Групповые чаты** | Создание групп, присоединение, обмен сообщениями |
| **Реал-тайм доставка** | Сообщения доставляются мгновенно через очереди |
| **Масштабируемость** | Поддержка многих одновременных клиентов |

**Архитектура системы:**
```
┌─────────────┐        ┌──────────────┐        ┌─────────────┐
│  Client 1   │───────▶│   Server     │◀───────│  Client 2   │
└─────────────┘        │              │        └─────────────┘
                       │  ZeroMQ      │
┌─────────────┐        │  Message     │        ┌─────────────┐
│  Client 3   │───────▶│  Queues      │◀───────│  Client N   │
└─────────────┘        └──────────────┘        └─────────────┘
                             │
                             ▼
                      ┌─────────────────┐
                      │ Управление      │
                      │ клиентами       │
                      │ Маршрутизация   │
                      │ групп           │
                      └─────────────────┘
```

**Технология:**
- **ZeroMQ** для асинхронных очередей сообщений
- POSIX сокеты для сетевого взаимодействия
- Многопроцессная архитектура для параллельной обработки

**Компоненты проекта:**

**Сервер (`server.c`):**
- Управление подключением и регистрацией клиентов
- Маршрутизация сообщений между клиентами
- Управление групповыми чатами (создание, присоединение, отправка)
- Обработка разрывов соединения
- Логирование событий

**Клиент (`client.c`):**
- Подключение к серверу и регистрация
- Интерфейс пользователя для отправки сообщений
- Получение сообщений в реальном времени
- Управление групповыми чатами

**Использование:**
```bash
cd cp_var23
make

# Терминал 1 — запуск сервера (bind на порт 5555)
./server.out

# Терминал 2 — клиенты подключаются по адресу сервера
./client.out tcp://localhost:5555
# После подключения происходит регистрация: вводится имя пользователя
Girday
```


## Материалы и ресурсы

Папка `theory/` содержит рекомендуемую учебную литературу:
- **Таненбаум Э.** — Современные операционные системы (Классика Computer Science)
- **Вахалия Д.** — Конспекты лекций и методические указания
- **Учебные материалы** — PDF с описанием файловых систем, аллокаторов памяти и других систем


## Заметки

- **Все работы** соответствуют стандартам POSIX и написаны на чистом C (C99+)
- **Makefile** позволяет легко собирать, запускать и очищать проекты
- **Варианты заданий** указаны в названиях папок (var5, var23 и т.д.)
- **Код** хорошо структурирован, документирован и следует единому стилю
- Для каждой работы выполнены **исходные коды, отчёты и презентации**
- **Все программы** протестированы и работают корректно на Linux/Ubuntu

<div align="center">

## 

**Григорьев Максим** • [@Girday](https://github.com/Girday)

Если код помог тебе понять что-то новое, поставь ⭐!

</div>
