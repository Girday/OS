В процессе работы стало ясно, как на практике устроено взаимодействие через mmap() и почему с ним приходится учитывать детали, которые не видны при использовании pipe. Неочевидным сначала было, что новый файл имеет размер 0 и mmap() не даст отобразить структуру, пока не выполнить ftruncate() - это объясняет, зачем вообще нужен ручной выбор размера. Стало понятнее, что разделяемая память - это просто общий участок адресного пространства, поэтому любое несинхронизированное обновление переменных мгновенно создаёт гонку: родитель легко мог перезаписать число или статус раньше, чем ребёнок их прочитает. Эту проблему пришлось решать через два POSIX-семафора, которые гарантируют строгий порядок действий: родитель записывает число, ребёнок обрабатывает, затем сигналит о завершении этапа. Также вспомнил о необходимости явно освобождать системные объекты (sem_destroy(), munmap(), unlink()), иначе после завершения программы остаются ресурсы, которые не удаляются автоматически. В итоге стало очевидно, что shared memory даёт прямой доступ к общим данным, но требует гораздо более строгой и аккуратной синхронизации, чем потоковый обмен через pipe.